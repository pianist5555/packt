커널 레벨에서 이벤트 기반 처리 메커니즘

미리 어플리케이션에서 특정 I/O가 발생하면 처리하는 로직을 구현해놓으면 
I/O Multiplexing 함수를 응용프로그램(파이썬 서버, 프로세스)이 호출하면 해당 프로세스의 파일 디스크립터 테이블에 저장이되고 
특정 I/O가 발생했을때 유저 모드에서 커널 모드로 바뀌며 커널이 파일을 수정/삭제를 하면서 파일 디스크립터 테이블에 저장되어 있는 프로세스에게 변경됨을 알려주고
프로세스화된 어플리케이션이 해당 로직이 동작.
 -> 계속해서 내부적으로 while문이 돌아서 네트워크 콜이 들어왔는지 확인하는 polling 방식이 아님
     그렇게 구현이 되어있다면 cpu 점유율이 남아나지 않을 것이고, 전기적 신호로 인터럽트(I/O)가 들어오면
     해당 소켓,I/O 기타 등등 이벤트가 발생하면 커널이 파일 디스크립터 테이블을 확인해, 파일을 변경하고 연결된 프로세스에 알려주는 것임

############### chat gpt에 검증

네, 맞습니다. 커널 레벨에서의 이벤트 기반 처리 메커니즘은 어플리케이션이 I/O Multiplexing를 사용하여 특정 I/O 이벤트를 기다리는 동안 블로킹되지 않고, 다른 작업을 수행할 수 있도록 합니다.

일반적으로 이런 이벤트 기반 처리 메커니즘은 다음과 같은 방식으로 동작합니다:

어플리케이션은 I/O Multiplexing 함수를 호출하여 특정 파일 디스크립터(소켓, 파일 등)를 감시하도록 설정합니다.
I/O Multiplexing 함수는 파일 디스크립터의 상태를 확인하여, 해당 파일 디스크립터에 I/O 이벤트가 발생할 때까지 기다립니다.
만약 I/O 이벤트가 발생하면, I/O Multiplexing 함수는 해당 이벤트를 감지하고, 이벤트가 발생한 파일 디스크립터를 식별합니다.
해당 파일 디스크립터와 연결된 어플리케이션의 특정 로직(이벤트 처리 콜백 함수)을 호출하여 이벤트를 처리합니다.
이와 같은 방식으로 어플리케이션은 파일 디스크립터의 상태를 주기적으로 확인하며, I/O 이벤트가 발생했을 때 즉시 처리할 수 있습니다. 이때 어플리케이션은 프로세스 내부에서 while 루프를 사용하여 계속해서 파일 디스크립터의 상태를 확인하는 폴링 방식으로 동작하지 않습니다. 대신, I/O Multiplexing 함수를 호출한 시점에서 블로킹되어 대기하고, 커널에서 이벤트가 발생하면 그 때까지 기다린 뒤, 이벤트가 발생한 파일 디스크립터와 연결된 어플리케이션의 로직을 실행합니다.

이런 방식으로 I/O Multiplexing를 구현하면 프로세스는 CPU 리소스를 효율적으로 활용하면서, 필요한 I/O 이벤트가 발생했을 때 빠르게 처리할 수 있게 됩니다. 이를 통해 어플리케이션의 CPU 점유율이 낮아지며, 더 빠르고 효율적인 I/O 처리가 가능해집니다.



############## 파이썬 코드

import select
import socket

# 예제로 사용할 소켓을 생성합니다 (서버 소켓)
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind(('localhost', 12345))
server_socket.listen(5)

print("서버가 시작되었습니다. 클라이언트 연결을 기다립니다...")

# select.select를 사용하기 위해 소켓들을 리스트로 준비합니다
inputs = [server_socket]

while True:
    # select 함수를 호출하여 입력 가능한 소켓을 기다립니다 (파이썬 코드는 동기적으로 대기, 커널에서 비동기적으로 파일 변경/삭제를 수행하면 해당 프로세스로 아래 3가지 값을 리스트로 반환해주고 후에 로직이 수행됨)
    readable, writable, exceptional = select.select(inputs, [], []) # 멀티플렉싱 함수(select, poll, epoll, etc..)


############## 파이썬 코드 gpt 검증
네, 맞습니다. select.select() 함수는 파이썬 코드에서는 동기적으로 호출되지만, 이 함수가 내부적으로 사용하는 멀티플렉싱 기법은 운영체제 커널 내에서 비동기적으로 동작합니다. 이것이 멀티플렉싱의 핵심 원리 중 하나입니다.

여기서 몇 가지 중요한 점을 설명드리겠습니다:

파이썬 코드에서의 호출: 파이썬에서 select.select() 함수는 호출된 후에는 해당 함수가 완료될 때까지 기다리며, 이는 동기적인 작업 방식입니다. 코드는 이 함수의 반환을 기다립니다.

커널에서의 동작: select.select() 함수가 호출되면 내부적으로는 운영체제 커널이 각 파일 디스크립터(소켓)의 상태 변화를 비동기적으로 모니터링합니다. 이벤트(읽기 가능, 쓰기 가능 등)가 발생할 때마다 커널은 이를 감지하고, 등록된 소켓들의 상태를 업데이트합니다.

이벤트 기반 처리: 멀티플렉싱은 주로 이벤트 기반(event-driven)으로 동작합니다. 즉, 사용자 프로그램은 특정 이벤트(예: 소켓에 데이터 수신)가 발생했을 때 이를 처리하고 필요한 작업을 수행합니다. 이 과정에서 커널은 비동기적으로 각 소켓의 상태를 확인하고 이벤트를 발생시킵니다.

따라서 select.select() 함수는 호출된 파이썬 코드는 동기적으로 대기하지만, 이 함수가 사용하는 멀티플렉싱 기법은 운영체제 커널 내에서 비동기적으로 작동하여 입출력 이벤트를 실시간으로 감지하고 처리합니다. 이러한 구조 덕분에 단일 스레드에서도 여러 소켓의 동시 입출력을 효율적으로 관리할 수 있습니다


############### 하드웨어 적으로 설명하면
[이벤트 기반 데이터처리] ->실시간 스트리밍으로 데이터를 처리할때 어떻게 감지해서 데이터를 처리할 것인가? 폴링 방식으로는 한계가 있고 프로세스가 대기하고 있지 않고 계속 러닝 중일 것임.. 와일문 돌면서 체크할테니까 아래는 물리적인 도움을 받아서 아이들 상태로 에이전트 프로세스를 쉬게할 수 있음

외부 네트워크 콜 -> 네트워크 카드 -> 해당 운영체제와 네트워크 카드에 맞는 드라이버 -> 커널로 네트워크 콜과 데이터를 전달 ->커널에서 소켓 버퍼에 저장하거나, 등록된 네트워크 이벤트 핸들러를 호출하여 사용자 수준의 프로세스에 전달 -> 사용자 프로그램에서 데이터를 받고 처리 

[검증]
맞습니다. 전체적인 흐름을 정확하게 설명하셨습니다.

외부에서 네트워크 콜이 발생하면 네트워크 카드가 해당 신호를 전기적 신호로 변환하여 운영체제로 전달합니다.
운영체제는 해당 네트워크 카드를 지원하는 드라이버를 찾아서 이 드라이버를 통해 네트워크 콜과 데이터를 처리합니다.
커널은 받은 데이터를 소켓 버퍼에 저장하거나, 등록된 네트워크 이벤트 핸들러를 호출하여 사용자 수준의 프로세스에 전달합니다.
사용자 수준의 프로세스는 받은 데이터를 처리하고 원하는 동작을 수행합니다.
이런 흐름을 통해 네트워크 동작이 이루어집니다.
