커널 레벨에서 이벤트 기반 처리 메커니즘

미리 어플리케이션에서 특정 I/O가 발생하면 처리하는 로직을 구현해놓으면
I/O Multiplexing가 파일 디스크립터의 상태를 확인하고 특정 I/O가 발생했을때,
프로세스화된 어플리케이션의 해당 로직이 동작.
 -> 계속해서 내부적으로 while문이 돌아서 네트워크 콜이 들어왔는지 확인하는 polling 방식이 아님
     그렇게 구현이 되어있다면 cpu 점유율이 남아나지 않을 것이고, 전기적 신호로 인터럽트(I/O)가 들어오면
     파일 디스크립터에 해당 소켓,I/O 기타 등등 이벤트가 발생하면 연결된 프로세스에 알려주는 것임

############### chat gpt에 검증

네, 맞습니다. 커널 레벨에서의 이벤트 기반 처리 메커니즘은 어플리케이션이 I/O Multiplexing를 사용하여 특정 I/O 이벤트를 기다리는 동안 블로킹되지 않고, 다른 작업을 수행할 수 있도록 합니다.

일반적으로 이런 이벤트 기반 처리 메커니즘은 다음과 같은 방식으로 동작합니다:

어플리케이션은 I/O Multiplexing 함수를 호출하여 특정 파일 디스크립터(소켓, 파일 등)를 감시하도록 설정합니다.
I/O Multiplexing 함수는 파일 디스크립터의 상태를 확인하여, 해당 파일 디스크립터에 I/O 이벤트가 발생할 때까지 기다립니다.
만약 I/O 이벤트가 발생하면, I/O Multiplexing 함수는 해당 이벤트를 감지하고, 이벤트가 발생한 파일 디스크립터를 식별합니다.
해당 파일 디스크립터와 연결된 어플리케이션의 특정 로직(이벤트 처리 콜백 함수)을 호출하여 이벤트를 처리합니다.
이와 같은 방식으로 어플리케이션은 파일 디스크립터의 상태를 주기적으로 확인하며, I/O 이벤트가 발생했을 때 즉시 처리할 수 있습니다. 이때 어플리케이션은 프로세스 내부에서 while 루프를 사용하여 계속해서 파일 디스크립터의 상태를 확인하는 폴링 방식으로 동작하지 않습니다. 대신, I/O Multiplexing 함수를 호출한 시점에서 블로킹되어 대기하고, 커널에서 이벤트가 발생하면 그 때까지 기다린 뒤, 이벤트가 발생한 파일 디스크립터와 연결된 어플리케이션의 로직을 실행합니다.

이런 방식으로 I/O Multiplexing를 구현하면 프로세스는 CPU 리소스를 효율적으로 활용하면서, 필요한 I/O 이벤트가 발생했을 때 빠르게 처리할 수 있게 됩니다. 이를 통해 어플리케이션의 CPU 점유율이 낮아지며, 더 빠르고 효율적인 I/O 처리가 가능해집니다.


############### 좀더 쉽게 얘기하면
[이벤트 기반 데이터처리] ->실시간 스트리밍으로 데이터를 처리할때 어떻게 감지해서 데이터를 처리할 것인가? 폴링 방식으로는 한계가 있고 프로세스가 대기하고 있지 않고 계속 러닝 중일 것임.. 와일문 돌면서 체크할테니까 아래는 물리적인 도움을 받아서 아이들 상태로 에이전트 프로세스를 쉬게할 수 있음

외부 네트워크 콜 -> 네트워크 카드 -> 해당 운영체제와 네트워크 카드에 맞는 드라이버 -> 커널로 네트워크 콜과 데이터를 전달 ->커널에서 소켓 버퍼에 저장하거나, 등록된 네트워크 이벤트 핸들러를 호출하여 사용자 수준의 프로세스에 전달 -> 사용자 프로그램에서 데이터를 받고 처리 

[검증]
맞습니다. 전체적인 흐름을 정확하게 설명하셨습니다.

외부에서 네트워크 콜이 발생하면 네트워크 카드가 해당 신호를 전기적 신호로 변환하여 운영체제로 전달합니다.
운영체제는 해당 네트워크 카드를 지원하는 드라이버를 찾아서 이 드라이버를 통해 네트워크 콜과 데이터를 처리합니다.
커널은 받은 데이터를 소켓 버퍼에 저장하거나, 등록된 네트워크 이벤트 핸들러를 호출하여 사용자 수준의 프로세스에 전달합니다.
사용자 수준의 프로세스는 받은 데이터를 처리하고 원하는 동작을 수행합니다.
이런 흐름을 통해 네트워크 동작이 이루어집니다.
