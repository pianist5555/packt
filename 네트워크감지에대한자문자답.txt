커널 레벨에서 이벤트 기반 처리 메커니즘

미리 어플리케이션에서 특정 I/O가 발생하면 처리하는 로직을 구현해놓으면
I/O Multiplexing가 파일 디스크립터의 상태를 확인하고 특정 I/O가 발생했을때,
프로세스화된 어플리케이션의 해당 로직이 동작.
 -> 계속해서 내부적으로 while문이 돌아서 네트워크 콜이 들어왔는지 확인하는 polling 방식이 아님
     그렇게 구현이 되어있다면 cpu 점유율이 남아나지 않을 것이고, 전기적 신호로 인터럽트(I/O)가 들어오면
     파일 디스크립터에 해당 소켓,I/O 기타 등등 이벤트가 발생하면 연결된 프로세스에 알려주는 것임

############### chat gpt에 검증

네, 맞습니다. 커널 레벨에서의 이벤트 기반 처리 메커니즘은 어플리케이션이 I/O Multiplexing를 사용하여 특정 I/O 이벤트를 기다리는 동안 블로킹되지 않고, 다른 작업을 수행할 수 있도록 합니다.

일반적으로 이런 이벤트 기반 처리 메커니즘은 다음과 같은 방식으로 동작합니다:

어플리케이션은 I/O Multiplexing 함수를 호출하여 특정 파일 디스크립터(소켓, 파일 등)를 감시하도록 설정합니다.
I/O Multiplexing 함수는 파일 디스크립터의 상태를 확인하여, 해당 파일 디스크립터에 I/O 이벤트가 발생할 때까지 기다립니다.
만약 I/O 이벤트가 발생하면, I/O Multiplexing 함수는 해당 이벤트를 감지하고, 이벤트가 발생한 파일 디스크립터를 식별합니다.
해당 파일 디스크립터와 연결된 어플리케이션의 특정 로직(이벤트 처리 콜백 함수)을 호출하여 이벤트를 처리합니다.
이와 같은 방식으로 어플리케이션은 파일 디스크립터의 상태를 주기적으로 확인하며, I/O 이벤트가 발생했을 때 즉시 처리할 수 있습니다. 이때 어플리케이션은 프로세스 내부에서 while 루프를 사용하여 계속해서 파일 디스크립터의 상태를 확인하는 폴링 방식으로 동작하지 않습니다. 대신, I/O Multiplexing 함수를 호출한 시점에서 블로킹되어 대기하고, 커널에서 이벤트가 발생하면 그 때까지 기다린 뒤, 이벤트가 발생한 파일 디스크립터와 연결된 어플리케이션의 로직을 실행합니다.

이런 방식으로 I/O Multiplexing를 구현하면 프로세스는 CPU 리소스를 효율적으로 활용하면서, 필요한 I/O 이벤트가 발생했을 때 빠르게 처리할 수 있게 됩니다. 이를 통해 어플리케이션의 CPU 점유율이 낮아지며, 더 빠르고 효율적인 I/O 처리가 가능해집니다.